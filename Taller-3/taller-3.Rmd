---
title: "Taller 2 Analisis Avanzado de Datos"
subtitle: "Maestria en Matem치ticas Aplicadas y Ciencias de la Computaci칩n"
author: 
  - "Carlos Daniel Barriga"
  - "Fabian Ricardo Luengas"
date: "2024-03-03"
output:
  rmdformats::downcute
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, include=FALSE}
library(readxl)
```

## Problema 1 - 20 pts (te칩rico)

Una familia de distribuciones \( P_\theta \) con \( \theta \in \Theta \) pertenece a la familia exponencial de distribuciones si su funci칩n de masa de probabilidad (fmp) o funci칩n de densidad de probabilidad (fdp) puede escribirse como:

\[ p(x|\eta) = h(x) \exp\left( \eta(\theta) \cdot t(x) - a(\theta) \right) \]

Para funciones reales \( h(x) \), \( a(\theta) \) y \( t(x) \), muestre que tanto la distribuci칩n Bernoulli (utilizada para la regresi칩n log칤stica), la distribuci칩n normal (utilizada en la regresi칩n lineal) y la distribuci칩n Poisson (utilizada en la regresi칩n Poisson sobre conteos) pertenecen a esta familia de distribuciones.


#### Funci칩n de Masa de Probabilidad de la distribuci칩n Bernoulli: 

$$
p(x|\theta) = \theta^x \cdot (1 - \theta)^{1-x}
$$

Donde 洧논 puede ser 0 o 1, y 洧랚 es la probabilidad de 칠xito.

Podemos expresar esta fmp en la forma requerida:

$$
p(x|\eta) = \exp(\eta \cdot x - \log(1 + \exp(\eta)))
$$
Donde:

- \( h(x) = 1 \)

- \( t(x) = x \)

- \( 풩 = \log\left(\frac{풪}{1 - 풪}\right) \)

- \( a(풩) = \log(1 + \exp(풩)) \)


#### Funci칩n de Masa de Probabilidad de la distribuci칩n normal: 

\[
f(x|\mu, \sigma^2) = \frac{1}{\sqrt{2\pi}\sigma} \exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)
\]

Podemos expresar esta fdp en la forma requerida:

\[
p(x|\eta) = \frac{1}{\sqrt{2\pi}} \exp\left(\eta x - \frac{\eta^2}{2}\right)
\]

Donde: 

- \( h(x) = \frac{1}{\sqrt{2\pi}\sigma} \)

- \( t(x) = x \)

- \( \eta = \frac{\mu}{\sigma^2} \)

- \( a(\eta) = \frac{\eta^2}{2} \)


#### Funci칩n de Masa de Probabilidad de la distribuci칩n Poisson: 

\[
p(x|\lambda) = \frac{e^{-\lambda}\lambda^x}{x!}
\]

Podemos expresar esta fmp en la forma requerida:

\[
p(x|\eta) = \exp(-e^\eta) \frac{e^{\eta x}}{x!}
\]

donde:

- \( h(x) = \frac{1}{x!} \)

- \( t(x) = x \)

- \( \eta = \log(\lambda) \)

- \( a(\eta) = e^\eta \).


## Problema 2 - 50 pts (pr치ctico). 

La Universidad de California Irvine (UCI) tiene un repositorio de datos de ejemplo para el uso de machine learning y aprendizaje estad칤stico. Uno de los conjuntos de
datos es el denominado Heart Disease, su descripci칩n detallada se encuentra en la URL a continuaci칩n:


Con el conjunto de datos completo, construya un modelo de regresi칩n log캼stico con funci칩n de enlace logit tomando como respuesta la presencia de la enfermedad cardiaca, use las dem치s variables como explicativas en el modelo de regresi칩n. Revise las URL dadas para la definici칩n de cada una de las variables y note que debe obtener la variable respuesta categorizando una de las variables del conjunto de datos. Siga los siguientes pasos en la realizaci칩n del ejercicio:


```{r}
columnas <- c("age","sex","cp","trestbps","chol","fbs","restecg","thalach","exang","oldpeak","slope","ca","thal","num")
datos <- read.csv("processed.cleveland.data.txt", col.names = columnas)
datos$num <- ifelse(datos$num == 0, 0, 1)
```


1. Imputar datos: El conjunto de datos tiene datos perdidos en algunas variables. Estos est치n notados con un ?. Impute los valores perdidos como la mediana de los datos para las variables correspondientes.
```{r, echo = TRUE}
# Convertir las columnas a num칠ricas
datos <- data.frame(apply(datos, 2, as.numeric))

# Imputar los valores perdidos con la mediana de cada columna
for (col in names(datos)) {
  datos[, col][is.na(datos[, col])] <- median(datos[, col], na.rm = TRUE)
}
```
```{r, echo = FALSE}
# Calcula el n칰mero de valores nulos en cada columna
nulos_por_columna <- colSums(is.na(datos))

# Imprime el n칰mero de valores nulos en cada columna
print(nulos_por_columna)
```

2. Revisar las distribuciones bivariadas: Revise la distribuci칩n de la variable respuesta para cada una de las co-variables categ칩ricas de manera bivariada. 쯢bserva alg칰n inconveniente con alguna de las variables al hacer el an치lisis?.

```{r}
# Crear tablas de contingencia entre la variable respuesta (num) y cada variable categ칩rica
tabla_cp <- table(datos$num, datos$cp)
tabla_sex <- table(datos$num, datos$sex)
tabla_cp <- table(datos$num, datos$cp)
tabla_sex <- table(datos$num, datos$sex)
tabla_fbs <- table(datos$num, datos$fbs)
tabla_restecg <- table(datos$num, datos$restecg)
tabla_slope <- table(datos$num, datos$slope)
# Agrega m치s tablas para otras variables categ칩ricas si es necesario

# Muestra las tablas de contingencia
print("Tabla de contingencia para la variable 'cp':")
print(tabla_cp)

print("Tabla de contingencia para la variable 'sex':")
print(tabla_sex)
# Agrega m치s impresiones de tablas para otras variables categ칩ricas si es necesario

```
```{r}
barplot(tabla_cp, beside = TRUE, legend = TRUE, main = "Variable CP vs. Respuesta")
```
Variable CP: tipo de dolor en el pecho
        -- Valor 1: angina t칤pica
        -- Valor 2: angina at칤pica
        -- Valor 3: dolor no anginoso
        -- Valor 4: asintom치tico

Se puede identificar una presencia de eventos de ataque cardiaco cuando el dolor es asintomatico 

```{r}
barplot(tabla_sex, beside = TRUE, legend = TRUE, main = "Variable Sex vs. Respuesta")
```
sexo: (1 = masculino; 0 = femenino)

Hay una mayor presencia de eventos de ataque cardiacos en hombres


```{r}
barplot(tabla_fbs, beside = TRUE, legend = TRUE, main = "Variable FBS vs. Respuesta")
```
fbs: (az칰car en sangre en ayunas > 120 mg/dl) (1 = verdadero; 0 = falso)

la presencia de azucar en sangre en ayunas no parece tener relaci칩n con la cantidad de registros de ataques al corazon

```{r}
barplot(tabla_restecg, beside = TRUE, legend = TRUE, main = "Variable Restecg vs. Respuesta")
```
restecg: resultados electrocardiogr치ficos en reposo
        -- Valor 0: normal
        -- Valor 1: tener anomal칤a de la onda ST-T (inversiones de la onda T y/o elevaci칩n o depresi칩n del ST > 0,05 mV)
        -- Valor 2: muestra probable o definitiva hipertrofia ventricular izquierda seg칰n los criterios de Estes
        
La variable parece tener relaci칩n con el evento de presentar un ataque cardiaco, donde el valor 2, que indica una hipertrofia ventricular ocasiona el aumento del riesgo en el evento.

```{r}
barplot(tabla_slope, beside = TRUE, legend = TRUE, main = "Variable Slope vs. Respuesta")
```
pendiente: la pendiente del segmento ST del ejercicio m치ximo
        -- Valor 1: pendiente ascendente
        -- Valor 2: plano
        -- Valor 3: pendiente descendente
        
El valor dos de esta variable parece aumentar el riesgo de presentar un ataque cardiaco.


3. Modelo bivariado: Calcule manualmente (como lo vimos en clase, a partir de la tabla de contingencia), los par치metros estimados de regresi칩n log칤stica considerando 칰nicamente la variable fbs (glucemia en ayunas) y la variable respuesta. Verifique el resultado ajustando el glm correspondiente.

```{r}
tabla_contingencia <- table(datos$num, datos$fbs)

print("Tabla de Contingencia para la variable 'fbs':")
print(tabla_contingencia)
```

```{r, echo= FALSE, results='hide'}
probabilidad_ataque_con_glucemia = (22/139)
probabilidad_no_ataque_con_glucemia = (117 / 139)

probabilidad_ataque_sin_glucemia = (22 / 163)
probabilidad_no_ataque_sin_glucemia = (141 / 163)

numerador = probabilidad_ataque_con_glucemia / probabilidad_no_ataque_con_glucemia
denominador =  probabilidad_ataque_sin_glucemia / probabilidad_no_ataque_sin_glucemia
```

```{r}
log(probabilidad_ataque_con_glucemia) - log(probabilidad_ataque_sin_glucemia)
```
```{r}
set.seed(1) 
n_tot=302 
rval_reprobado =runif(n_tot) 
prop_reprobado =44/302
h0_reporbado = ifelse(rval_reprobado<prop_reprobado,"A.Ataque","B.No_ataque") 
rval_asistencia =runif(n_tot) 
prop_asistencia =139/302 
h0_asistencia =ifelse(rval_asistencia <prop_reprobado,"A.Glucemia","B.Sin_glucemia") 
h0_tablacont = table(h0_asistencia,h0_reporbado) 
print(h0_tablacont)
```
```{r}

h0_or = (h0_tablacont[1,1]/h0_tablacont[1,2])/(h0_tablacont[2,1]/h0_tablacont[2,2]) 
print(h0_or)

```
Modelo logistico Bivariado

```{r}
# Ajustar un modelo de regresi칩n log칤stica utilizando glm()
modelo_logistico <- glm(num ~ fbs, data = datos, family = binomial)

# Imprime el resumen del modelo
summary(modelo_logistico)$coefficients
```

4. Modelo multivariado: Ajuste un nuevo modelo con todas las variables. 쮺u치les variables son significativas mediante el test de Wald? 쮺u치les no lo son?.

```{r}
# Ajustar un modelo de regresi칩n log칤stica con todas las variables
modelo_multivariado <- glm(num ~ ., data = datos, family = binomial)

# Imprimir el resumen del modelo
summary(modelo_multivariado)
```

5. Visualizaci칩n de probabilidades predichas bajo modelo multivariado: Usando el modelo del punto anterior, encuentre las probabilidades de presentar enfermedad cardiaca y visualizarlas junto a la variable respuesta. 쮻escribe el modelo la presencia de enfermedad cardiaca?.

```{r}
# Calcular las probabilidades predichas bajo el modelo multivariado
datos$probabilidades <- predict(modelo_multivariado, type = "response")

# Visualizar las probabilidades predichas junto con la variable respuesta
library(ggplot2)
ggplot(datos, aes(x = num, y = probabilidades)) +
  geom_point(aes(color = factor(num))) +
  geom_smooth(method = "glm", method.args = list(family = "binomial")) +
  labs(x = "Enfermedad card칤aca", y = "Probabilidad predicha") +
  scale_color_discrete(name = "Enfermedad card칤aca") +
  theme_minimal()
```

## Problema 3 - 30 pts (pr치ctico) 

El conjunto de datos AAD-taller03.xlsx contiene la predicci칩n de incumplimiento de pago de tarjeta de cr칠dito bajo dos modelos log칤sticos diferentes para un total de 9080 clientes. Se cuenta adem치s con la variable de incumplimiento observada al finalizar el periodo.

쮺u치l de los dos modelos log칤sticos tiene mayor poder de predicci칩n? Explique con fundamento estad칤stico su resultado.


```{r cars}
df <- read_excel("AAD-taller03.xlsx")
df
```

Calculando la Curva ROC, para el modelo 1:

```{r}
library(ROCR)
## Modelo 1 

pred_1 <- ROCR::prediction(df$ScoreLogisticoA,df$Incumplimiento)
perf_1 <- ROCR::performance(pred_1,'tpr','fpr')
plot(perf_1)
```

calculando la curva ROC para el modelo 2:

```{r}
pred_2 <- ROCR::prediction(df$ScoreLogisticoB,df$Incumplimiento)
perf_2 <- ROCR::performance(pred_2,'tpr','fpr')
plot(perf_2)
```

```{r}
#areas bajo la curva
auc_1 <- ROCR::performance(pred_1,measure = 'auc')
auc_1@y.values
auc_2 <- ROCR:: performance(pred_2,measure = 'auc')
auc_2@y.values
```

Aunque grafica y estadisticamente hablando podemos notar que ambos modelos tienen un bajo poder de predicci칩n general, podemos deducir que el modelo 1 tiene un mayor poder de predicci칩n que el modelo 2, con base a su curva ROC, pues el area bajo la curva de esta es de `r auc_1@y.values[[1]]`, siendo mayor que la del modelo 2 y mostrando por tanto mayor poder de predicci칩n en comparaci칩n.

## Punto 4

```{r}
columnas <- c("age","sex","cp","trestbps","chol","fbs","restecg","thalach","exang","oldpeak","slope","ca","thal","num")
datos <- read.csv("processed.cleveland.data.txt", col.names = columnas)
datos$num <- ifelse(datos$num == 0, 0, 1)
```

```{r}
datos <- data.frame(apply(datos, 2, as.numeric))

```
```{r}
library(mixtools)

for (col in names(datos)) {
  if(sum(is.na(datos[col]) != 0 )){
    dat <- datos[!is.na(datos[col]),col]
    mixem <- mixtools::normalmixEM(dat, k=2)
  }
}
```


